package caddy

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"
	
	"github.com/aran/mdns-caddy/internal/cert"
	"github.com/aran/mdns-caddy/internal/profile"
)

// PortMapping defines a mapping from external (Caddy) port to internal (localhost) port
type PortMapping struct {
	ExternalPort int // The port Caddy listens on
	InternalPort int // The port on localhost to forward to
}

type Config struct {
	MDNSHostnames      []string      // Hostnames for mDNS service (back.local)
	TargetHostnames    []string      // Target domain hostnames (dev.getplans.io)
	ServerPort         int           // HTTP server port
	PortMappings       []PortMapping // Port mappings (external:internal)
	LocalTLSCertPath   string        // Path to local TLS certificate
	LocalTLSKeyPath    string        // Path to local TLS key
	TargetTLSCertPath  string        // Path to target TLS certificate
	TargetTLSKeyPath   string        // Path to target TLS key
}

const DefaultConfigPath = "Caddyfile"

func GenerateConfig(
	mdnsHostnames []string, 
	allHostnames []string, 
	serverPort int, 
	portMappings []PortMapping, 
	outputPath string,
) (bool, bool, error) {
	if len(allHostnames) == 0 {
		return false, false, fmt.Errorf("no hostnames provided for Caddy configuration")
	}

	cwd, err := os.Getwd()
	if err != nil {
		return false, false, fmt.Errorf("error getting current directory: %w", err)
	}

	certManager := cert.NewManager(cwd)
	profileManager := profile.NewProfileManager(cwd)
	
	certGenerated := false
	profileGenerated := false

	_, err = os.Stat(certManager.Paths.RootCAPath)
	if err != nil {
		certGenerated = true
	}

	if err := certManager.EnsureCA(); err != nil {
		return false, false, fmt.Errorf("error ensuring CA exists: %w", err)
	}

	// Check if either local or target certificates exist
	_, localCertErr := os.Stat(certManager.Paths.LocalCertPath)
	_, targetCertErr := os.Stat(certManager.Paths.TargetCertPath)
	if localCertErr != nil || targetCertErr != nil {
		certGenerated = true
	}

	// Generate separate certificates for local (.local) and target domains
	if err := certManager.EnsureLocalCertificate(mdnsHostnames); err != nil {
		return false, false, fmt.Errorf("error ensuring local certificate exists: %w", err)
	}
	
	// Extract target hostnames (everything except mDNS hostnames)
	var targetHostnames []string
	for _, h := range allHostnames {
		isMDNSHostname := false
		for _, mdnsHost := range mdnsHostnames {
			if h == mdnsHost {
				isMDNSHostname = true
				break
			}
		}
		if !isMDNSHostname {
			targetHostnames = append(targetHostnames, h)
		}
	}
	
	// Generate certificate for target domains
	if err := certManager.EnsureTargetCertificate(targetHostnames); err != nil {
		return false, false, fmt.Errorf("error ensuring target certificate exists: %w", err)
	}

	if certGenerated || !profileManager.ProfileExists() {
		// Update to pass target hostnames to the profile generator
		if err := profileManager.GenerateProfile(certManager.Paths.RootCAPath, mdnsHostnames[0], targetHostnames[0]); err != nil {
			return certGenerated, false, fmt.Errorf("error generating provisioning profile: %w", err)
		}
		profileGenerated = !profileManager.ProfileExists()
	}

	localTLSCertPath, err := filepath.Rel(cwd, certManager.Paths.LocalCertPath)
	if err != nil {
		return certGenerated, profileGenerated, fmt.Errorf("error getting relative path for local certificate: %w", err)
	}
	
	localTLSKeyPath, err := filepath.Rel(cwd, certManager.Paths.LocalKeyPath)
	if err != nil {
		return certGenerated, profileGenerated, fmt.Errorf("error getting relative path for local key: %w", err)
	}
	
	targetTLSCertPath, err := filepath.Rel(cwd, certManager.Paths.TargetCertPath)
	if err != nil {
		return certGenerated, profileGenerated, fmt.Errorf("error getting relative path for target certificate: %w", err)
	}
	
	targetTLSKeyPath, err := filepath.Rel(cwd, certManager.Paths.TargetKeyPath)
	if err != nil {
		return certGenerated, profileGenerated, fmt.Errorf("error getting relative path for target key: %w", err)
	}

	const caddyTemplate = `# This Caddyfile was automatically generated by mdns-caddy
# To regenerate: run the mdns-caddy application
{
	admin off
	# Disable automatic HTTPS on port 443
	auto_https disable_redirects
}

# mDNS hostnames (serve HTTP, DNS over HTTPS, and profile download)
{{ range .MDNSHostnames }}
{{ . }} {
	tls {{ $.LocalTLSCertPath }} {{ $.LocalTLSKeyPath }}
	
	# Handle DNS-over-HTTPS requests
	handle /dns-query {
		reverse_proxy localhost:{{ $.ServerPort }}
	}
	
	# Handle all other paths
	handle {
		reverse_proxy localhost:{{ $.ServerPort }}
	}
}

{{ end }}

# Target domain hostnames with specific port mappings
{{ range .TargetHostnames }}
{{ $hostname := . }}

# Setup server blocks for each port mapping
{{ range $.PortMappings }}
{{ $hostname }}:{{ .ExternalPort }} {
	tls {{ $.TargetTLSCertPath }} {{ $.TargetTLSKeyPath }}
	
	# Forward all traffic to the internal port
	reverse_proxy http://localhost:{{ .InternalPort }}
}
{{ end }}

{{ end }}
`
	tmpl, err := template.New("caddy").Parse(caddyTemplate)
	if err != nil {
		return certGenerated, profileGenerated, fmt.Errorf("error parsing Caddy template: %w", err)
	}

	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return certGenerated, profileGenerated, fmt.Errorf("error creating directory %s: %w", dir, err)
	}

	file, err := os.Create(outputPath)
	if err != nil {
		return certGenerated, profileGenerated, fmt.Errorf("error creating Caddy config file: %w", err)
	}
	defer file.Close()

	config := Config{
		MDNSHostnames:     mdnsHostnames,
		TargetHostnames:   targetHostnames,
		ServerPort:        serverPort,
		PortMappings:      portMappings,
		LocalTLSCertPath:  localTLSCertPath,
		LocalTLSKeyPath:   localTLSKeyPath,
		TargetTLSCertPath: targetTLSCertPath,
		TargetTLSKeyPath:  targetTLSKeyPath,
	}
	if err := tmpl.Execute(file, config); err != nil {
		return certGenerated, profileGenerated, fmt.Errorf("error executing Caddy template: %w", err)
	}

	return certGenerated, profileGenerated, nil
}